<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Text Extractor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        window.MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)']],
                displayMath: [['\\[', '\\]']],
                processEscapes: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            }
        };
    </script>
</head>
<body class="bg-gray-100 min-h-screen">
    {% raw %}
    <div id="app" v-cloak class="container mx-auto px-4 py-4">
        <div class="flex gap-4">
            <!-- Left Column: History and Image Upload -->
            <div class="w-1/5">
                <!-- Upload Section -->
                <div class="bg-white rounded-lg shadow-md p-4 mb-4">
                    <h3 class="text-lg font-semibold mb-3">Upload</h3>
                    <div 
                        @dragover.prevent="dragover = true"
                        @dragleave.prevent="dragover = false"
                        @drop.prevent="handleDrop"
                        :class="{'border-blue-500 bg-blue-50': dragover}"
                        class="mb-4 border-2 border-dashed rounded-lg transition-colors duration-200">
                        <div class="flex flex-col items-center justify-center h-24">
                            <svg xmlns="http://www.w3.org/2000/svg" class="w-8 h-8 text-gray-400" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z" clip-rule="evenodd" />
                            </svg>
                            <p class="mt-2 text-xs text-gray-600">
                                Drop PDF or
                                <label class="text-blue-500 hover:text-blue-600 cursor-pointer">
                                    <span>browse</span>
                                    <input type="file" class="hidden" accept=".pdf" @change="handleFileUpload">
                                </label>
                            </p>
                        </div>
                    </div>

                    <!-- Error Alert -->
                    <div v-if="error" class="bg-red-100 border border-red-400 text-red-700 px-3 py-2 rounded text-sm mb-4">
                        <span v-text="error"></span>
                    </div>

                    <!-- Loading State -->
                    <div v-if="loading" class="text-center py-2">
                        <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-gray-900 mx-auto"></div>
                        <p class="mt-2 text-sm text-gray-600">Processing...</p>
                    </div>
                </div>

                <!-- History Section -->
                <div class="bg-white rounded-lg shadow-md p-4">
                    <div class="flex justify-between items-center mb-3">
                        <h3 class="text-lg font-semibold">History</h3>
                        <button 
                            @click="clearHistory" 
                            class="text-sm text-red-600 hover:text-red-800 transition-colors"
                            :disabled="!fileHistory.length">
                            Clear All
                        </button>
                    </div>
                    <div class="space-y-2 max-h-[400px] overflow-y-auto">
                        <div v-for="(item, index) in fileHistory" :key="index" 
                             class="p-2 bg-gray-50 rounded hover:bg-gray-100 cursor-pointer text-sm"
                             @click="loadHistoryItem(item)">
                            <p class="font-medium truncate" v-text="item.name"></p>
                            <p class="text-xs text-gray-500" v-text="item.timestamp"></p>
                        </div>
                        <div v-if="!fileHistory.length" class="text-sm text-gray-500 text-center py-4">
                            No files processed yet
                        </div>
                    </div>
                </div>
            </div>

            <!-- Middle Column: PDF Preview -->
            <div class="w-2/5">
                <div class="bg-white rounded-lg shadow-md p-6">
                    <h3 class="text-lg font-semibold mb-4">PDF Preview</h3>
                    <div v-if="pdfUrl" class="w-full h-[700px] overflow-y-auto bg-gray-50 rounded-lg">
                        <iframe :src="pdfUrl" class="w-full h-full" type="application/pdf"></iframe>
                    </div>
                    <div v-else class="w-full h-[700px] flex items-center justify-center bg-gray-50 rounded-lg">
                        <p class="text-gray-500">Upload a PDF to preview</p>
                    </div>
                </div>
            </div>

            <!-- Right Column: Extracted Content -->
            <div class="w-2/5" v-if="result && result.success">
                <div class="bg-white rounded-lg shadow-md p-6">
                    <!-- Document Information Section -->
                    <div class="bg-gray-50 rounded-lg p-4 mb-4">
                        <h3 class="text-lg font-semibold mb-2">Document Information</h3>
                        <p class="text-gray-600 mb-4">Total Pages: <span v-text="result.total_pages"></span></p>
                        
                        <!-- Indexing Status and Control -->
                        <div class="mb-4 flex items-center justify-between">
                            <div class="flex items-center space-x-2">
                                <span class="text-sm font-medium text-gray-700">Indexing Status:</span>
                                <span v-if="result.is_indexed" class="text-green-600 text-sm">
                                    <i class="fas fa-check-circle"></i> Indexed
                                </span>
                                <span v-else class="text-gray-600 text-sm">
                                    <i class="fas fa-times-circle"></i> Not Indexed
                                </span>
                            </div>
                            <button v-if="!result.is_indexed" 
                                    @click="apiKey ? indexDocument(result.id) : showApiKeyModal = true"
                                    :disabled="indexing"
                                    class="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600 disabled:bg-gray-300">
                                <span v-if="!indexing">
                                    <span v-if="apiKey">Index Document</span>
                                    <span v-else>Add API Key to Index</span>
                                </span>
                                <span v-else>
                                    <i class="fas fa-spinner fa-spin"></i> Indexing...
                                </span>
                            </button>
                        </div>
                        
                        <!-- Metadata -->
                        <div v-if="result.metadata && Object.keys(result.metadata).length" class="space-y-2">
                            <h4 class="font-medium text-gray-700">Metadata</h4>
                            <div class="grid gap-2">
                                <template v-for="(value, key) in result.metadata" :key="key">
                                    <div v-if="value" class="text-sm">
                                        <span class="font-medium text-gray-700" v-text="formatMetadataKey(key) + ':'"></span>
                                        <span class="ml-2 text-gray-600" v-text="formatMetadataValue(value)"></span>
                                    </div>
                                </template>
                            </div>
                        </div>
                    </div>

                    <!-- Content Section -->
                    <div class="max-h-[600px] overflow-y-auto">
                        <div v-for="page in result.content" :key="page.page" class="mb-8 pb-6 border-b border-gray-200">
                            <h4 class="font-semibold mb-4 text-lg">Page <span v-text="page.page"></span></h4>
                            
                            <!-- Text Content -->
                            <div class="bg-gray-50 rounded-lg p-4 mb-4">
                                <div class="whitespace-pre-wrap text-gray-700" v-html="page.content || 'No content found on this page.'"></div>
                            </div>

                            <!-- Tables -->
                            <div v-if="page.tables && page.tables.length" class="mb-4">
                                <h5 class="font-medium mb-2 text-gray-700">Tables</h5>
                                <div v-for="(table, tableIndex) in page.tables" :key="tableIndex" class="mb-4 overflow-x-auto">
                                    <table class="min-w-full border border-gray-200">
                                        <tbody>
                                            <tr v-for="(row, rowIndex) in table" :key="rowIndex" 
                                                :class="{'bg-gray-50': rowIndex % 2 === 0}">
                                                <td v-for="(cell, cellIndex) in row" :key="cellIndex"
                                                    class="px-4 py-2 border border-gray-200 text-sm">
                                                    <span v-if="cell !== null">{{ cell }}</span>
                                                    <span v-else>&nbsp;</span>
                                                </td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </div>
                            </div>

                            <!-- Images -->
                            <div v-if="page.images && page.images.length" class="mb-4">
                                <h5 class="font-medium mb-2 text-gray-700">Images</h5>
                                <div class="grid grid-cols-2 gap-4">
                                    <div v-for="(image, imageIndex) in page.images" :key="imageIndex" 
                                         class="relative group">
                                        <img :src="image.data" 
                                             :alt="'Image ' + (imageIndex + 1)"
                                             class="w-full rounded-lg shadow-sm hover:shadow-md transition-shadow cursor-zoom-in"
                                             @click="openImageModal(image)">
                                        <div class="absolute bottom-2 right-2 bg-black bg-opacity-50 text-white px-2 py-1 rounded text-xs">
                                            {{ image.type.toUpperCase() }}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Image Modal -->
        <div v-if="selectedImage" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
             @click="selectedImage = null">
            <div class="max-w-4xl max-h-[90vh] overflow-auto bg-white rounded-lg p-4">
                <img :src="selectedImage.data" :alt="'Full size image'" class="max-w-full h-auto">
            </div>
        </div>

        <!-- API Key Modal -->
        <div v-if="showApiKeyModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4" @click.stop>
                <h3 class="text-lg font-semibold mb-2">OpenAI API Key</h3>
                <p class="text-gray-600 text-sm mb-4">Enter your OpenAI API key to enable the chat assistant feature.</p>
                <div class="mb-4">
                    <input type="password" 
                           v-model="apiKey" 
                           class="w-full px-3 py-2 border rounded focus:outline-none focus:ring-2 focus:ring-blue-500"
                           placeholder="Enter your OpenAI API key">
                </div>
                <div class="flex justify-end space-x-2">
                    <button @click="showApiKeyModal = false" 
                            class="px-4 py-2 bg-gray-300 rounded hover:bg-gray-400">
                        Cancel
                    </button>
                    <button @click="saveApiKey" 
                            class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
                        Save
                    </button>
                </div>
            </div>
        </div>

        <!-- Chat Widget -->
        <div class="fixed bottom-4 right-4 z-50">
            <!-- Chat Button -->
            <button @click="toggleChat" 
                    class="w-14 h-14 rounded-full bg-blue-500 text-white shadow-lg flex items-center justify-center hover:bg-blue-600 transition-colors">
                <i class="fas" :class="chatOpen ? 'fa-times' : 'fa-comments'"></i>
            </button>

            <!-- Chat Window -->
            <div v-if="chatOpen" 
                 class="absolute bottom-16 right-0 w-96 bg-white rounded-lg shadow-xl overflow-hidden">
                <!-- Chat Header -->
                <div class="bg-blue-500 text-white p-4 flex justify-between items-center">
                    <h3 class="font-semibold">
                        <span v-if="result && result.is_indexed">RAG-Enabled PDF Assistant</span>
                        <span v-else>PDF Assistant</span>
                    </h3>
                    <div class="flex items-center space-x-2">
                        <button v-if="!apiKey" 
                                @click="showApiKeyModal = true"
                                class="text-sm px-2 py-1 bg-blue-600 rounded hover:bg-blue-700">
                            Add API Key
                        </button>
                        <button @click="clearChat" 
                                class="text-sm px-2 py-1 bg-blue-600 rounded hover:bg-blue-700">
                            Clear
                        </button>
                    </div>
                </div>

                <!-- API Key Not Set Message -->
                <div v-if="!apiKey" class="p-4 bg-gray-50 text-center">
                    <p class="text-gray-600 mb-2">OpenAI API key not set</p>
                    <button @click="showApiKeyModal = true" 
                            class="text-blue-500 hover:text-blue-600">
                        Click here to add your API key
                    </button>
                </div>

                <!-- Chat Messages -->
                <div v-else class="h-96 overflow-y-auto p-4 space-y-4" ref="chatMessages">
                    <div v-if="result && result.is_indexed" class="text-center text-sm text-gray-500 pb-2">
                        Using RAG for document-specific answers
                    </div>
                    <div v-for="(message, index) in chatMessages" 
                         :key="index" 
                         :class="{'flex justify-end': message.role === 'user'}">
                        <div :class="{
                            'bg-blue-100 rounded-lg p-3 max-w-[80%]': message.role === 'user',
                            'bg-gray-100 rounded-lg p-3 max-w-[80%]': message.role === 'assistant'
                        }">
                            <p class="text-sm whitespace-pre-wrap" v-html="message.content"></p>
                        </div>
                    </div>
                    <div v-if="chatLoading" class="flex justify-center">
                        <div class="animate-spin rounded-full h-6 w-6 border-b-2 border-blue-500"></div>
                    </div>
                </div>

                <!-- Chat Input -->
                <div v-if="apiKey" class="border-t p-4">
                    <div class="flex space-x-2">
                        <textarea v-model="userInput" 
                                 @keydown.enter.prevent="sendMessage"
                                 placeholder="Ask a question about your PDF..."
                                 class="flex-1 px-3 py-2 border rounded resize-none focus:outline-none focus:ring-2 focus:ring-blue-500"
                                 rows="2"></textarea>
                        <button @click="sendMessage" 
                                :disabled="!apiKey || chatLoading"
                                class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:bg-gray-300 disabled:cursor-not-allowed">
                            <i class="fas fa-paper-plane"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    {% endraw %}

    <style>
        [v-cloak] {
            display: none;
        }
        ::-webkit-scrollbar {
            width: 6px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }
        ::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 3px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        .mjx-chtml {
            margin: 0.5em 0 !important;
        }
    </style>

    <script>
        const { createApp } = Vue

        createApp({
            data() {
                return {
                    loading: false,
                    error: null,
                    result: null,
                    dragover: false,
                    pdfUrl: null,
                    fileHistory: [],
                    selectedImage: null,
                    // Chat related data
                    chatOpen: false,
                    showApiKeyModal: false,
                    apiKey: localStorage.getItem('openai_api_key') || '',
                    userInput: '',
                    chatMessages: [],
                    chatLoading: false,
                    indexing: false,
                }
            },
            mounted() {
                this.loadHistory();
                // Only show API key modal if no key is found
                if (!this.apiKey) {
                    this.showApiKeyModal = true;
                }
            },
            methods: {
                async handleDrop(e) {
                    this.dragover = false
                    const file = e.dataTransfer.files[0]
                    if (file && file.type === 'application/pdf') {
                        await this.processFile(file)
                    } else {
                        this.error = 'Please drop a valid PDF file'
                    }
                },
                async handleFileUpload(event) {
                    const file = event.target.files[0]
                    if (!file) return
                    await this.processFile(file)
                },
                async processFile(file) {
                    this.loading = true
                    this.error = null
                    this.result = null
                    this.pdfUrl = null

                    const formData = new FormData()
                    formData.append('file', file)

                    try {
                        const response = await fetch('/upload', {
                            method: 'POST',
                            body: formData
                        })

                        const data = await response.json()
                        
                        if (!response.ok) {
                            throw new Error(data.error || 'Failed to process PDF')
                        }

                        // Save PDF file to server and get permanent URL
                        const saveResponse = await fetch('/save_pdf', {
                            method: 'POST',
                            body: formData
                        })
                        
                        const saveData = await saveResponse.json()
                        if (!saveResponse.ok) {
                            throw new Error(saveData.error || 'Failed to save PDF')
                        }

                        this.result = saveData.result  // Use the result from save_pdf which includes ID
                        this.pdfUrl = saveData.pdfUrl

                        // Add to history with the extracted text and permanent URL
                        this.addToHistory({
                            name: file.name,
                            timestamp: new Date().toLocaleString(),
                            result: saveData.result,  // Use the result with ID
                            pdfUrl: saveData.pdfUrl,
                            id: saveData.id
                        })

                        // Trigger MathJax to process new content
                        this.$nextTick(() => {
                            if (window.MathJax) {
                                window.MathJax.typesetPromise();
                            }
                        });
                    } catch (err) {
                        this.error = err.message
                    } finally {
                        this.loading = false
                    }
                },
                async loadHistory() {
                    try {
                        const response = await fetch('/history')
                        const data = await response.json()
                        if (response.ok) {
                            this.fileHistory = data
                        }
                    } catch (err) {
                        console.error('Failed to load history:', err)
                    }
                },
                async addToHistory(historyItem) {
                    this.fileHistory.unshift(historyItem)
                    if (this.fileHistory.length > 10) {
                        const removedItem = this.fileHistory.pop()
                        // Notify server to remove old PDF if needed
                        if (removedItem.id) {
                            try {
                                await fetch(`/remove_pdf/${removedItem.id}`, { method: 'DELETE' })
                            } catch (err) {
                                console.error('Failed to remove old PDF:', err)
                            }
                        }
                    }
                },
                async loadHistoryItem(historyItem) {
                    this.result = historyItem.result
                    this.pdfUrl = historyItem.pdfUrl
                    
                    // Check indexing status
                    if (this.apiKey) {
                        try {
                            const response = await fetch(`/check_index/${historyItem.id}`, {
                                headers: {
                                    'X-API-Key': this.apiKey
                                }
                            });
                            const data = await response.json();
                            if (response.ok) {
                                this.result.is_indexed = data.is_indexed;
                            }
                        } catch (err) {
                            console.error('Error checking index status:', err);
                        }
                    }
                    
                    // Trigger MathJax to process new content
                    this.$nextTick(() => {
                        if (window.MathJax) {
                            window.MathJax.typesetPromise();
                        }
                    });
                },
                async clearHistory() {
                    if (confirm('Are you sure you want to clear all history?')) {
                        try {
                            await fetch('/clear_history', { method: 'POST' })
                            this.fileHistory = []
                            this.result = null
                            this.pdfUrl = null
                        } catch (err) {
                            console.error('Failed to clear history:', err)
                        }
                    }
                },
                openImageModal(image) {
                    this.selectedImage = image
                },
                // Chat related methods
                toggleChat() {
                    this.chatOpen = !this.chatOpen;
                    if (!this.apiKey && this.chatOpen) {
                        this.showApiKeyModal = true;
                    }
                },
                async sendMessage() {
                    if (!this.userInput.trim() || !this.apiKey || this.chatLoading) return;

                    const userMessage = this.userInput.trim();
                    this.chatMessages.push({ role: 'user', content: userMessage });
                    this.userInput = '';
                    this.chatLoading = true;

                    try {
                        const response = await fetch('/chat', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-API-Key': this.apiKey
                            },
                            body: JSON.stringify({
                                message: userMessage,
                                history: this.chatMessages,
                                doc_id: this.result?.id
                            })
                        });

                        const data = await response.json();
                        if (response.ok) {
                            this.chatMessages.push({ role: 'assistant', content: data.response });
                            this.$nextTick(() => {
                                const chatMessages = this.$refs.chatMessages;
                                chatMessages.scrollTop = chatMessages.scrollHeight;
                            });
                        } else {
                            throw new Error(data.error || 'Failed to get response');
                        }
                    } catch (err) {
                        this.chatMessages.push({
                            role: 'assistant',
                            content: 'Sorry, I encountered an error: ' + err.message
                        });
                    } finally {
                        this.chatLoading = false;
                    }
                },
                saveApiKey() {
                    localStorage.setItem('openai_api_key', this.apiKey);
                    this.showApiKeyModal = false;
                },
                clearChat() {
                    this.chatMessages = [];
                },
                formatMetadataKey(key) {
                    return key.replace(/^\//, '')
                        .split(/(?=[A-Z])/)
                        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                        .join(' ');
                },
                formatMetadataValue(value) {
                    if (typeof value === 'string' && value.startsWith('D:')) {
                        try {
                            const date = new Date(
                                value.slice(2, 6),
                                value.slice(6, 8) - 1,
                                value.slice(8, 10),
                                value.slice(10, 12),
                                value.slice(12, 14),
                                value.slice(14, 16)
                            );
                            return date.toLocaleString();
                        } catch (e) {
                            return value;
                        }
                    }
                    return value;
                },
                async indexDocument(docId) {
                    if (!this.apiKey || this.indexing) return;
                    
                    this.indexing = true;
                    try {
                        const response = await fetch(`/index_document/${docId}`, {
                            method: 'POST',
                            headers: {
                                'X-API-Key': this.apiKey
                            }
                        });
                        
                        const data = await response.json();
                        if (response.ok) {
                            this.result.is_indexed = true;
                        } else {
                            throw new Error(data.error || 'Failed to index document');
                        }
                    } catch (err) {
                        console.error('Error indexing document:', err);
                        alert('Failed to index document: ' + err.message);
                    } finally {
                        this.indexing = false;
                    }
                },
            }
        }).mount('#app')
    </script>
</body>
</html> 